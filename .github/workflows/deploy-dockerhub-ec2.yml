name: Deploy to EC2 (DockerHub)

on:
  push:
    branches: [ "main" ]

concurrency:
  group: deploy
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      IMAGE_NAME: muuigong/stock-app
      DEPLOY_DIR: /srv/stock

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & Push image
        run: |
          docker build -t "$IMAGE_NAME:latest" .
          docker push "$IMAGE_NAME:latest"

      - name: SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Add known_hosts (robust)
        shell: bash
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          HOST="${EC2_HOST#*@}"      # strip user@
          HOST="${HOST%%:*}"         # strip :port if any
          HOST="$(printf '%s' "$HOST" | tr -d '\r\n')"
          if [ -z "$HOST" ]; then
            echo "❌ EC2_HOST invalid. Expected 'user@host'." >&2
            exit 1
          fi
          echo "→ adding $HOST to known_hosts"
          ssh-keyscan -T 15 -H "$HOST" >> ~/.ssh/known_hosts 2>/dev/null
          chmod 644 ~/.ssh/known_hosts

      - name: Upload compose & optional .env (first-time friendly)
        shell: bash
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          DEPLOY_DIR: /srv/stock
          APP_ENV_FILE: ${{ secrets.APP_ENV_FILE }}   # optional
        run: |
          set -euo pipefail
          # 로그 디렉토리 생성 (볼륨 마운트용)
          ssh -o StrictHostKeyChecking=no "$EC2_HOST" "mkdir -p $DEPLOY_DIR/logs"
          # config 디렉토리 생성
          ssh -o StrictHostKeyChecking=no "$EC2_HOST" "mkdir -p $DEPLOY_DIR/config"
          # 항상 최신 docker-compose.yml 업로드 (로그 볼륨 설정 등 최신 변경사항 반영)
          scp -o StrictHostKeyChecking=no docker-compose.yml "$EC2_HOST:$DEPLOY_DIR/docker-compose.yml"
          # upload .env if provided via secret
          if [ -n "${APP_ENV_FILE:-}" ]; then
            printf "%s" "$APP_ENV_FILE" | ssh -o StrictHostKeyChecking=no "$EC2_HOST" "cat > $DEPLOY_DIR/config/.env && chmod 600 $DEPLOY_DIR/config/.env"
          fi

      - name: Pull & Restart on EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          DEPLOY_DIR: /srv/stock
        run: |
          ssh -o StrictHostKeyChecking=no "$EC2_HOST" "
            set -e
            cd $DEPLOY_DIR
            
            echo '=== 기존 컨테이너 정리 중 ==='
            # 기존 컨테이너 중지 및 제거 (orphan 포함)
            docker compose down --remove-orphans || true
            
            echo '=== 443 포트 사용 중인 컨테이너 확인 및 종료 ==='
            # 모든 실행 중인 컨테이너 확인
            docker ps --format '{{.ID}}\t{{.Names}}\t{{.Ports}}' | grep -E '0\.0\.0\.0:443|443->443|:443' || true
            
            # 포트 매핑으로 호스트의 443 포트를 사용하는 컨테이너 찾기 및 종료
            docker ps --format '{{.ID}}' | while read container_id; do
              port_mapping=\$(docker port \"\$container_id\" 2>/dev/null || echo '')
              if echo \"\$port_mapping\" | grep -qE ':443|443/tcp'; then
                container_name=\$(docker ps --format '{{.Names}}' --filter \"id=\$container_id\")
                echo \"443 포트를 사용하는 컨테이너 발견: \$container_id (\$container_name)\"
                docker stop \"\$container_id\" || true
                docker rm \"\$container_id\" || true
              fi
            done || true
            
            # docker inspect를 사용하여 포트 바인딩 확인 (더 정확함)
            docker ps -a --format '{{.ID}}' | while read container_id; do
              port_bindings=\$(docker inspect \"\$container_id\" --format '{{range \$p, \$conf := .HostConfig.PortBindings}}{{\$p}} {{end}}' 2>/dev/null || echo '')
              host_ports=\$(docker inspect \"\$container_id\" --format '{{range \$p, \$conf := .HostConfig.PortBindings}}{{range \$conf}}{{.HostPort}} {{end}}{{end}}' 2>/dev/null || echo '')
              if echo \"\$host_ports\" | grep -qE '^443 | 443 |443$'; then
                container_name=\$(docker inspect \"\$container_id\" --format '{{.Name}}' 2>/dev/null || echo '')
                echo \"443 포트를 사용하는 컨테이너 발견 (inspect): \$container_id (\$container_name)\"
                docker stop \"\$container_id\" 2>/dev/null || true
                docker rm \"\$container_id\" 2>/dev/null || true
              fi
            done || true
            
            # 남아있는 모든 stockproject 관련 컨테이너 강제 종료
            docker ps -a --filter \"name=stockproject\" --format '{{.ID}}' | while read container_id; do
              [ -n \"\$container_id\" ] && docker rm -f \"\$container_id\" || true
            done || true
            
            echo '=== 443 포트 사용 중인 시스템 프로세스 확인 ==='
            # 443 포트를 사용하는 시스템 프로세스 확인 (권한 필요하지만 정보만 출력)
            sudo lsof -ti:443 2>/dev/null | head -5 | while read pid; do
              echo \"포트 443을 사용하는 프로세스 발견 (PID: \$pid)\"
              ps -p \"\$pid\" -o pid,cmd || true
            done || echo 'lsof를 사용할 수 없거나 포트를 사용하는 프로세스가 없습니다'
            
            # 잠시 대기 (포트 해제 시간 확보)
            sleep 2
            
            echo '=== 최신 이미지 Pull ==='
            # 최신 이미지 pull
            docker compose pull
            
            echo '=== 컨테이너 시작 ==='
            # 컨테이너 시작
            docker compose up -d
            
            echo '=== 정리 및 상태 확인 ==='
            # 사용하지 않는 이미지 정리
            docker image prune -f
            
            # 상태 확인
            docker ps
            echo '=== 배포 완료 ==='
          "
